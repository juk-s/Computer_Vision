# Лабораторная 2
**Задание:** Трекинг плоского объекта на видео с восстановлением после потери (LK Optical Flow + Homography (RANSAC) + Re-detect по первому кадру)

---

## Теоретическая база

### 1) Характерные точки (Corners / Features)
Для трекинга объекта удобнее работать не со всем изображением, а с набором **опорных точек** на объекте (обычно углы и контрастные детали).  
В работе опорные точки для межкадрового трекинга выбираются функцией OpenCV:

- **`cv.goodFeaturesToTrack`** (Shi–Tomasi): находит устойчивые «углы» (точки с выраженным изменением яркости по X и по Y).

---

### 2) Оптический поток Лукаса–Канаде (Pyramidal LK)
Метод **Lucas–Kanade** оценивает, как сдвинулась каждая опорная точка между двумя соседними кадрами.

На практике это выглядит так:
- на кадре *t-1* есть точка `(x, y)`;
- на кадре *t* алгоритм находит для неё новое положение `(x', y')`.

В OpenCV используется функция:

- **`cv.calcOpticalFlowPyrLK`** — пирамидальный LK (работает по нескольким масштабам изображения, поэтому устойчивее при больших смещениях).

---

### 3) Гомография (Homography)
Так как объект считается **плоским**, его видимое преобразование между кадрами можно описать **гомографией** — матрицей `3×3`:

\[
\mathbf{x'} \sim \mathbf{H}\mathbf{x}
\]

где:
- \(\mathbf{x}\) — точка на предыдущем/эталонном кадре (в однородных координатах),
- \(\mathbf{x'}\) — соответствующая точка на текущем кадре,
- \(\mathbf{H}\) — матрица гомографии.

В OpenCV гомография вычисляется:

- **`cv.findHomography`**

---

### 4) RANSAC, inliers и outliers
В трекинге и сопоставлении точек всегда появляются ошибки:
- часть точек трекается неверно,
- часть совпадений признаков оказывается ложной.

Чтобы построить устойчивую модель, применяется **RANSAC**:
- **inliers** — согласованные точки, которые хорошо описываются найденной гомографией,
- **outliers** — выбросы (ошибочные точки/совпадения), которые RANSAC игнорирует.

---

### 5) Переобнаружение (Re-detect) по первому кадру
Если межкадровый трекинг сорвался, объект восстанавливается по **первому кадру как эталону**:
1) На первом кадре вычисляются признаки (AKAZE).
2) На текущем кадре вычисляются признаки (AKAZE).
3) Выполняется matching дескрипторов.
4) По совпадениям снова оценивается гомография (RANSAC), и рамка объекта восстанавливается.

---

### 6) Предобработка CLAHE
**CLAHE** (Contrast Limited Adaptive Histogram Equalization) — локальное усиление контраста.  
Используется для повышения устойчивости детекции/матчинга на размытых и низкоконтрастных кадрах.

---

## Описание разработанной системы

### Входные и выходные данные
- **Вход:** `test-videos/mona-lisa-blur-extra-credit.avi`
- **Выход:** `results/t1_mona-lisa-blur-extra-credit.avi` (видео с рамкой объекта)

### Использованные функции OpenCV
- `cv.goodFeaturesToTrack` — выбор углов для LK-трекинга
- `cv.calcOpticalFlowPyrLK` — перенос точек между соседними кадрами
- `cv.findHomography(..., cv.RANSAC, ...)` — оценка гомографии с отбрасыванием выбросов
- `cv.perspectiveTransform` — перенос рамки (4 угла) по гомографии
- `cv.AKAZE_create`, `detectAndCompute` — признаки и дескрипторы для переобнаружения
- `cv.BFMatcher(cv.NORM_HAMMING)` — сопоставление бинарных дескрипторов (Hamming)
- `cv.createCLAHE` — предобработка (контраст)

---

## Алгоритм работы (по шагам)

### 1) Инициализация (первый кадр)
1. Считывается первый кадр видео.
2. Перевод в grayscale.
3. Предобработка `CLAHE`.
4. Вычисление признаков **AKAZE** на первом кадре: `kp0, des0`.
5. Рамка объекта задаётся как весь кадр (`corners0` — четыре угла).
6. Внутри рамки выбираются углы `goodFeaturesToTrack` — стартовые точки `p_prev`.

### 2) Обработка каждого следующего кадра
На каждом кадре выполняется:

#### Режим TRACK (если `lost == False`)
1. Точки `p_prev` переносятся на текущий кадр через `calcOpticalFlowPyrLK` → `p_next`.
2. Выполняется обратный перенос `p_back` (для контроля стабильности трека).
3. По соответствующим точкам строится **гомография** `Hm` (prev → cur) через `findHomography(..., RANSAC, ...)`.
4. Если количество **inliers** достаточно:
   - рамка объекта `corners` обновляется: `corners = perspectiveTransform(corners, Hm)`;
   - для следующего шага берутся точки-inliers.
5. Если гомография не строится или inliers мало — включается `lost=True`.

#### Режим REDETECT (если `lost == True`)
1. На текущем кадре считаются признаки AKAZE.
2. Выполняется matching с дескрипторами первого кадра.
3. По совпадениям строится гомография `Habs` (1-й кадр → текущий).
4. Если `Habs` найдена:
   - рамка восстанавливается как `perspectiveTransform(corners0, Habs)`;
   - внутри восстановленной рамки заново выбираются точки для LK;
   - `lost=False`, возвращение в режим TRACK.

### 3) Визуализация и запись результата
- Рамка рисуется на кадре:
  - зелёный цвет — трекинг успешен,
  - красный цвет — объект потерян (идёт восстановление).
- Кадры записываются в выходное видео.

---

## Параметры (использованные в коде)

- `MAX_CORNERS = 1000`  
  Максимум углов/точек для LK-трекинга внутри рамки объекта.

- `MIN_INLIERS_LK = 20`  
  Минимальное количество inliers, чтобы принять гомографию в режиме TRACK.

- `CLAHE(clipLimit=2.0, tileGridSize=(8, 8))`  
  Параметры локального усиления контраста:
  - `clipLimit` ограничивает усиление (чтобы не усиливать шум),
  - `tileGridSize` задаёт размер сетки блоков для локальной обработки.

- `RANSAC`  
  Используется в `findHomography` для подавления выбросов.

---

## Результаты работы
В результате работы формируется видео с рамкой объекта на каждом кадре.  
Алгоритм поддерживает:
- изменение масштаба и ракурса (за счёт гомографии),
- восстановление после потери (за счёт re-detect по первому кадру).

---

## Выводы по работе
1. Для плоских объектов корректной моделью является **гомография**, так как она учитывает перспективные искажения.
2. LK-трекинг по точкам обеспечивает быстрый межкадровый трек, но может срываться при сильном размытии/ошибках трека.
3. Переобнаружение по первому кадру с AKAZE и RANSAC позволяет восстановить трекинг после потери.
4. RANSAC и контроль числа inliers являются ключевыми элементами устойчивости.

---

## Использованные источники
- Richard Szeliski. *Computer Vision: Algorithms and Applications*
- Документация OpenCV:
  - https://docs.opencv.org/4.x/d7/d8b/tutorial_py_lucas_kanade.html
  - https://docs.opencv.org/4.x/d4/d8c/tutorial_py_shi_tomasi.html
  - https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html (findHomography)
  - https://docs.opencv.org/4.x/db/d70/tutorial_akaze_matching.html
  - https://docs.opencv.org/4.x/d6/dc7/group__imgproc__hist.html (CLAHE)
